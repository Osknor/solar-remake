<!DOCTYPE html>
<style>

button {
  position: absolute;
  top: 10px;
  left: 10px;
}

circle {
  fill: none;
  stroke: #c4c4c4;
  stroke-width: 1.5px;
}

</style>
<button>Click Me</button>
<svg width="960" height="800"></svg>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://unpkg.com/javascript-lp-solver/prod/solver.js"></script>
<script src="./rings.js"></script>
<script>

var svg = d3.select("svg"),
    margin = {top: 30, right: 30, bottom: 30, left: 30},
    width = +svg.attr("width") - margin.left - margin.right,
    height = +svg.attr("height") - margin.top - margin.bottom,
    g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");


    d3.select("button").on("click", function() {
        console.log(k);
        k++;



//   circle.transition()
//       .duration(750)
//       .ease(d3.easeCubicOut)
//       .attr("r", 3.5+clicks*10)
//       .attr("stroke-opacity", 1)
    // .transition()
    //   .delay(5000 - 750 * 2)
    //   .ease(d3.easeCubicIn)
    //   .attr("r", 80)
    //   .attr("stroke-opacity", 0)
    //   .remove();
});







//var data2 = {"matrix":[{"id":0,"type":0,"l1":"amniotic","l2":"","dist":[0,0.50206,0.561944,0.601928,0.60922,0.6286,0.662024,0.662212,0.693956,0.702204,0.708352,0.708516,0.710436,0.713976,0.715548,0.717152,0.717192,0.719368,0.72264,0.724072]},{"id":1,"type":0,"l1":"amnion","l2":"","dist":[0.50206,0,0.896952,0.237976,0.88862,0.450784,0.4163,0.867156,0.834416,1.007816,0.612916,0.568376,0.772708,0.832148,0.923952,0.76302,0.89872,0.725936,0.901404,0.912028]},{"id":2,"type":0,"l1":"amniotic fluid","l2":"","dist":[0.561944,0.896952,0,0.991588,0.270588,0.9999,0.861008,0.84046,0.862468,0.62214,0.84652,0.921436,0.965496,0.875972,0.882232,0.86052,0.878196,0.940936,0.872584,0.312564]},{"id":3,"type":7,"l1":"subject:amnion metabolism","l2":"","dist":[0.601928,0.237976,0.991588,0.000256,0.971728,0.403484,0.559232,0.929716,0.827016,0.940136,0.667432,0.665116,0.771124,0.844608,0.95022,0.787604,0.933196,0.8599,0.98932,1.031708]},{"id":4,"type":7,"l1":"subject:amniotic fluid chemistry","l2":"","dist":[0.60922,0.88862,0.270588,0.971728,0,0.969788,0.80294,0.806448,0.842792,0.673832,0.808176,0.858944,0.938324,0.83492,0.902448,0.885012,0.900396,0.94424,0.888196,0.42624]},{"id":5,"type":7,"l1":"subject:amnion cytology","l2":"","dist":[0.6286,0.450784,0.9999,0.403484,0.969788,0,0.79814,0.963996,0.996272,1.068048,0.86994,0.652932,0.887928,0.918712,0.858012,0.788408,0.842176,1.013764,0.960696,0.995056]},{"id":6,"type":0,"l1":"chorion","l2":"","dist":[0.662024,0.4163,0.861008,0.559232,0.80294,0.79814,0.000976,0.920372,0.896568,0.888304,0.569108,0.647664,0.858268,0.859828,0.952184,0.904636,0.942612,0.596392,0.868996,0.94004]},{"id":7,"type":2,"l1":"author:horii t","l2":"","dist":[0.662212,0.867156,0.84046,0.929716,0.806448,0.963996,0.920372,0.000536,0.881652,0.877352,0.887756,0.8532,0.87224,0.916436,0.82336,0.964904,0.849868,0.842668,0.901908,0.95434]},{"id":8,"type":7,"l1":"subject:chorioamnionitis microbiology","l2":"","dist":[0.693956,0.834416,0.862468,0.827016,0.842792,0.996272,0.896568,0.881652,0,0.434764,0.904232,1.00944,0.743612,0.952128,0.921808,0.928932,0.90648,0.917892,0.832124,0.963084]},{"id":9,"type":7,"l1":"subject:amniotic fluid microbiology","l2":"","dist":[0.702204,1.007816,0.62214,0.940136,0.673832,1.068048,0.888304,0.877352,0.434764,0.000508,0.901276,0.975452,0.819752,0.875304,0.952468,0.980784,0.9593,0.918692,0.909312,0.810936]},{"id":10,"type":7,"l1":"subject:extraembryonic membranes metabolism","l2":"","dist":[0.708352,0.612916,0.84652,0.667432,0.808176,0.86994,0.569108,0.887756,0.904232,0.901276,0,0.866772,0.83144,0.954584,1.036612,0.905324,0.964736,0.742852,0.956756,0.90308]},{"id":11,"type":7,"l1":"subject:amnion enzymology","l2":"","dist":[0.708516,0.568376,0.921436,0.665116,0.858944,0.652932,0.647664,0.8532,1.00944,0.975452,0.866772,0,1.01764,0.87974,0.936224,0.871652,0.922024,0.827016,0.92486,0.992024]},{"id":12,"type":7,"l1":"subject:amnion pathology","l2":"","dist":[0.710436,0.772708,0.965496,0.771124,0.938324,0.887928,0.858268,0.87224,0.743612,0.819752,0.83144,1.01764,0.000492,0.845524,0.914984,0.954512,0.926216,0.823512,0.927264,0.950896]},{"id":13,"type":0,"l1":"jacobs","l2":"","dist":[0.713976,0.832148,0.875972,0.844608,0.83492,0.918712,0.859828,0.916436,0.952128,0.875304,0.954584,0.87974,0.845524,0,0.912188,0.956068,0.89526,0.941884,1.09288,0.819224]},{"id":14,"type":7,"l1":"subject:papain","l2":"","dist":[0.715548,0.923952,0.882232,0.95022,0.902448,0.858012,0.952184,0.82336,0.921808,0.952468,1.036612,0.936224,0.914984,0.912188,0.001016,0.864536,0.151476,1.019764,0.890284,0.870392]},{"id":15,"type":7,"l1":"subject:hearing loss sensorineural prevention and control","l2":"","dist":[0.717152,0.76302,0.86052,0.787604,0.885012,0.788408,0.904636,0.964904,0.928932,0.980784,0.905324,0.871652,0.954512,0.956068,0.864536,0.000432,0.812408,0.901744,0.890904,0.884652]},{"id":16,"type":7,"l1":"subject:papain metabolism","l2":"","dist":[0.717192,0.89872,0.878196,0.933196,0.900396,0.842176,0.942612,0.849868,0.90648,0.9593,0.964736,0.922024,0.926216,0.89526,0.151476,0.812408,0,1.042416,0.874532,0.8739]},{"id":17,"type":0,"l1":"chorionic","l2":"","dist":[0.719368,0.725936,0.940936,0.8599,0.94424,1.013764,0.596392,0.842668,0.917892,0.918692,0.742852,0.827016,0.823512,0.941884,1.019764,0.901744,1.042416,0,0.922572,0.993776]},{"id":18,"type":7,"l1":"subject:antibody specificity genetics","l2":"","dist":[0.72264,0.901404,0.872584,0.98932,0.888196,0.960696,0.868996,0.901908,0.832124,0.909312,0.956756,0.92486,0.927264,1.09288,0.890284,0.890904,0.874532,0.922572,0.000292,0.942248]},{"id":19,"type":7,"l1":"subject:amniotic fluid metabolism","l2":"","dist":[0.724072,0.912028,0.312564,1.031708,0.42624,0.995056,0.94004,0.95434,0.963084,0.810936,0.90308,0.992024,0.950896,0.819224,0.870392,0.884652,0.8739,0.993776,0.942248,0.001784]}],"attributes":[{"label":"text","value":"."},{"label":"subject","value":"subject"},{"label":"author","value":"author"},{"label":"citation","value":"citation"},{"label":"issn","value":"issn"},{"label":"inst","value":"inst"},{"label":"type","value":"type"},{"label":"pdate","value":"pdate"},{"label":"lang","value":"lang"}]}

//import * as data2 from './rings.json';
// var data2 = {"matrix":[{"id":0,"dist":[0,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],"l1":"c1","l2":"","type":9},
// {"id":1,"dist":[1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"l1":"c2","l2":"","type":9},
// {"id":2,"dist":[1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"l1":"c3","l2":"","type":9},
// {"id":3,"dist":[1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"l1":"c4","l2":"","type":9},
// {"id":4,"dist":[1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"l1":"c5","l2":"","type":9},
// {"id":5,"dist":[1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"l1":"c6","l2":"","type":9},
// {"id":6,"dist":[1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"l1":"c7","l2":"","type":9},
// {"id":7,"dist":[1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"l1":"c8","l2":"","type":9},
// {"id":8,"dist":[1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"l1":"c9","l2":"","type":9},
// {"id":9,"dist":[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"l1":"c10","l2":"","type":9},
// {"id":10,"dist":[1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"l1":"c11","l2":"","type":9},
// {"id":11,"dist":[1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"l1":"c12","l2":"","type":9},
// {"id":12,"dist":[1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"l1":"c13","l2":"","type":9},
// {"id":13,"dist":[2,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"l1":"c14","l2":"","type":9},
// {"id":14,"dist":[2,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"l1":"c15","l2":"","type":9},
// {"id":15,"dist":[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"l1":"c16","l2":"","type":9},
// {"id":16,"dist":[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"l1":"c17","l2":"","type":9},
// {"id":17,"dist":[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"l1":"c18","l2":"","type":9},
// {"id":18,"dist":[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],"l1":"c19","l2":"","type":9},
// {"id":19,"dist":[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1],"l1":"c20","l2":"","type":9},
// {"id":20,"dist":[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1],"l1":"c21","l2":"","type":9},
// {"id":21,"dist":[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1],"l1":"c22","l2":"","type":9},
// {"id":22,"dist":[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1],"l1":"c23","l2":"","type":9},
// {"id":23,"dist":[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1],"l1":"c24","l2":"","type":9},
// {"id":24,"dist":[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1],"l1":"c25","l2":"","type":9},
// {"id":25,"dist":[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1],"l1":"c26","l2":"","type":9},
// {"id":26,"dist":[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1],"l1":"c27","l2":"","type":9},
// {"id":27,"dist":[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1],"l1":"c28","l2":"","type":9},
// {"id":28,"dist":[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1],"l1":"c29","l2":"","type":9},
// {"id":29,"dist":[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1],"l1":"c30","l2":"","type":9},
// {"id":30,"dist":[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],"l1":"c31","l2":"","type":9},
// {"id":31,"dist":[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],"l1":"c32","l2":"","type":9}],"records":[]}
//center = data2.matrix[0].dist.slice(1);
//matrix = data2.matrix.slice(1).map( item=> item.dist.slice(1));
k = 4
center = data2.matrix[0].dist;
matrix = data2.matrix.map( item => item.dist);
console.time('test');
//var histogram = d3.histogram().thresholds( d3.thresholdSturges(center))
// console.log("saker",center.slice(1).map((item,index,source) => {
//     if (index!=0){
//         return [item-source[index-1],item,source[index-1], (item+source[index-1])/2,index]
//     }
// }).sort((a,b)=> b[0] -a[0]));

// matrix = [
// [0,1,1,1,1,1,1],
// [1,0,2,1,10,10,2],
// [1,2,0,2,10,10,10],
// [1,1,2,0,2,10,10],
// [1,10,10,2,0,2,1],
// [1,10,10,10,2,0,2],
// [1,2,10,10,1,2,0],
// ];

// matrix = [
//     [0,1,1,Math.sqrt(2),1,Math.sqrt(2),Math.sqrt(2),Math.sqrt(1+Math.sqrt(2)*Math.sqrt(2))],
//     [1,0,Math.sqrt(2),1,Math.sqrt(2),1,Math.sqrt(1+Math.sqrt(2)*Math.sqrt(2)),Math.sqrt(2)],
//     [1,Math.sqrt(2),0,1,Math.sqrt(2),Math.sqrt(1+Math.sqrt(2)*Math.sqrt(2)),1,Math.sqrt(2)],
//     [Math.sqrt(2),1,1,0,Math.sqrt(1+Math.sqrt(2)*Math.sqrt(2)),Math.sqrt(2),Math.sqrt(2),1],
//     [1,Math.sqrt(2),Math.sqrt(2),Math.sqrt(1+Math.sqrt(2)*Math.sqrt(2)),0,1,1,Math.sqrt(2)],
//     [Math.sqrt(2),1,Math.sqrt(1+Math.sqrt(2)*Math.sqrt(2)),Math.sqrt(2),1,0,Math.sqrt(2),1],
//     [Math.sqrt(2),Math.sqrt(1+Math.sqrt(2)*Math.sqrt(2)),1,Math.sqrt(2),1,Math.sqrt(2),0,1],
//     [Math.sqrt(1+Math.sqrt(2)*Math.sqrt(2)),Math.sqrt(2),Math.sqrt(2),1,Math.sqrt(2),6,1,0],
// ]
// center = [0,1,1,Math.sqrt(2),1,Math.sqrt(2),Math.sqrt(2),Math.sqrt(1+Math.sqrt(2)*Math.sqrt(2))];
matrix = [
    [0,1,1,2,1,2,2,3],
    [1,0,2,1,2,1,3,2],
    [1,2,0,1,2,3,1,2],
    [2,1,1,0,3,2,2,1],
    [1,2,2,3,0,1,1,2],
    [2,1,3,2,1,0,2,1],
    [2,3,1,2,1,2,0,1],
    [3,2,2,1,2,6,1,0],
]

center = [0,1,1,2,1,2,2,3];
// center = [0,1,1,1,1,1,1];
var buckets = bucketing([...center],k);




//console.log(histogram(center.slice(1)),"ble");

console.log(center,matrix,'input');

data = {
        "matrix":
        [
            {"id":0,"type":0,"l1":"hej","l2":"","dist":[0,0.150892,0.193208,0.265368,0.477596,0.530136,0.568216,0.619612,0.640268,0.67056]},
            {"id":1,"type":0,"l1":"baillie","l2":"","dist":[0.150892,0,0.073024,0.148884,0.4411,0.913292,0.445892,0.9296,0.576004,0.984748]},
            {"id":2,"type":2,"l1":"author:baillie j","l2":"","dist":[0.193208,0.073024,0,0.211568,0.50298,0.932272,0.495544,0.945944,0.5952,0.959224]},
            {"id":3,"type":0,"l1":"jonathan","l2":"","dist":[0.265368,0.148884,0.211568,0.000016,0.490956,0.915732,0.529164,0.932508,0.576896,1.024148]},
            {"id":4,"type":0,"l1":"estates","l2":"","dist":[0.477596,0.4411,0.50298,0.490956,0.0004,0.986068,0.655688,0.986372,0.79898,0.965256]},
            {"id":5,"type":0,"l1":"hej mice","l2":"","dist":[0.530136,0.913292,0.932272,0.915732,0.986068,0.002368,0.995524,0.271356,1.044168,0.358232]},
            {"id":6,"type":7,"l1":"subject:maintenance and engineering hospital","l2":"","dist":[0.568216,0.445892,0.495544,0.529164,0.655688,0.995524,0.000428,0.94608,0.764608,0.976092]},
            {"id":7,"type":0,"l1":"heouj","l2":"","dist":[0.619612,0.9296,0.945944,0.932508,0.986372,0.271356,0.94608,0.001504,0.980528,0.593068]},
            {"id":8,"type":7,"l1":"subject:hospitals public","l2":"","dist":[0.640268,0.576004,0.5952,0.576896,0.79898,1.044168,0.764608,0.980528,0.000188,0.974156]},
            {"id":9,"type":0,"l1":"ouj","l2":"","dist":[0.67056,0.984748,0.959224,1.024148,0.965256,0.358232,0.976092,0.593068,0.974156,0]}
      ],
        "attributes":
        [
            {"label":"text","value":"."},
            {"label":"subject","value":"subject"},
            {"label":"author","value":"author"},
            {"label":"citation","value":"citation"},
            {"label":"issn","value":"issn"},
            {"label":"inst","value":"inst"},
            {"label":"type","value":"type"},
            {"label":"pdate","value":"pdate"},
            {"label":"lang","value":"lang"}
        ]
    };
    
    //buckets =[];
    //center = [0.150892,0.193208,0.265368,0.3677596,0.530136,0.548216,0.619612,0.640268,0.67056];

    range = Math.max(...center)- Math.min(...center);
    //poses = center.map( value =>Math.floor((value- Math.min(... center))/(range/k))==k?k-1:Math.floor((value- Math.min(...center))/(range/k))+1);
    console.log('buckets',buckets)
    poses = center.slice(0).map(item => {
        var count = 0;
        buckets.forEach(placement => {
            if (item>placement[3]){
                count++;
            }
        })
        return count;
    })
    matrices = [];
    centers = [];
    original = [];
    results = [];
    difference = []
    k++;
    poses[0] = 0;
    for (i = 0; i<k; i++){ 
        matrices[i] = [];
        centers[i] = [];
        original[i] = [];
    }
    console.log("pos bis",poses);
    

    // matrix=
    //     [
    //         [0,0.073024,0.148884,0.4411,0.913292,0.445892,0.9296,0.576004,0.984748],
    //         [0.073024,0,0.211568,0.50298,0.932272,0.495544,0.945944,0.5952,0.959224],
    //         [0.148884,0.211568,0.000016,0.490956,0.915732,0.529164,0.932508,0.576896,1.024148],
    //         [0.4411,0.50298,0.490956,0.0004,0.986068,0.655688,0.986372,0.79898,0.965256],
    //         [0.913292,0.932272,0.915732,0.986068,0.002368,0.995524,0.271356,1.044168,0.358232],
    //         [0.445892,0.495544,0.529164,0.655688,0.995524,0.000428,0.94608,0.764608,0.976092],
    //         [0.9296,0.945944,0.932508,0.986372,0.271356,0.94608,0.001504,0.980528,0.593068],
    //         [0.576004,0.5952,0.576896,0.79898,1.044168,0.764608,0.980528,0.000188,0.974156],
    //         [0.984748,0.959224,1.024148,0.965256,0.358232,0.976092,0.593068,0.974156,0]
    //   ];
poses.forEach((pos,index,source)=> {
    centers[pos].push(center[index])
    original[pos].push(index);
    matrices[pos].push(matrix[index].filter((list,indexInner) => pos == poses[indexInner]))
    });
console.log(matrices,centers,original);
for (var iii = 0; iii<k; iii++){
    
    if (matrices[iii].length > 0){
         results[iii] = tsp(matrices[iii],centers[iii],original[iii],solver,matrix);
        results[iii].ii = iii;
        console.log(results[iii]);
        console.log(results[iii].placements.reduce((sum,add) => sum + add))
    }
    

}

//console.log(results,results.filter(d => d),"FGDJSAFDSAFSD");


console.log(results);


if (results[0]){
    results[0].neg = 1;
    results[0].turn = 0;
}
extra = [];
for(var i = 1;i<k; i++){ // calculate positions of rotation and direction
    extra[i] = [];
    if (results[i]){
    var points = Object.assign({}, results[i]); 
    points.id = points.shortestCycle;
    counter = 0;
    points.pos =[];
    points.rot = [];
    for (var turn = 0; turn < 2*Math.PI; turn += Math.PI/10 ){
        for (var neg = 1; neg > -2 ; neg-=2){
            points.rot[counter] = {"turn":turn,"neg":neg};
            if(points.shortestCycle) points.pos[counter] = points.placements.map((item,index) => mod(neg*item+turn,Math.PI*2));
            counter++
        }
    }
    data = distortionCalculator(i,points,results,matrix,extra);
    console.log('data extra',data.extra);
    difference[i] = data.bestDif;
    console.log(results[i])
        results[i].rota = points.rot[data.bestPlacement];
        results[i].turn = points.rot[data.bestPlacement].turn;
        results[i].neg = points.rot[data.bestPlacement].neg;
        if (results[i].neg == -1){
            results[i].placements.reverse();
            results[i].shortestCycle.reverse();
            results[i].center.reverse();
            results[i].distances.reverse();
        }
        results[i].placements = results[i].placements.map( pos => {
            //console.log('posss',results[i].rota,pos, mod((pos*results[i].neg + results[i].turn),(Math.PI*2)));
            return mod((pos + results[i].turn),(Math.PI*2))
        });
    }
}
//results.forEach((result,index) => results[index].placements = result.placements.map( pos =>  mod((pos*result.neg + result.turn),(Math.PI*2))));
console.log("bling",difference,results);
totalDiff = results.map( item=> Infinity);
sumDiff = Infinity;
nn =0;
improving = true;
while (improving && nn< 1000){
    for(var i = 0;i<k; i++){

        if (results[i]){
            results[i].shortestCycle.forEach((item,index,source) =>{ 
                forbidden = [];
                if (source.length > 1 ){
                    bl= 1;
                forbidden.push([results[i].placements[mod((index-1),results[i].placements.length)]+ matrix[item][source[mod((index-1),results[i].placements.length)]]/(results[i].radius* 1),
                    results[i].placements[mod((index+1),results[i].placements.length)]- matrix[item][source[mod((index+1),results[i].placements.length)]]/(results[i].radius* 1)])
                    ;
                   if(item=="9") console.log([results[i].placements[mod((index+1),results[i].placements.length)]- matrix[item][source[mod((index+1),results[i].placements.length)]]/(results[i].radius* 1)
                     , results[i].placements[mod((index-1),results[i].placements.length)]+ matrix[item][source[mod((index-1),results[i].placements.length)]]/(results[i].radius* 1)],
                     " haha",index,results[i].placements[index],
                     results[i].placements[mod((index-1),results[i].placements.length)], matrix[item][source[mod((index-1),results[i].placements.length)]],"piss",(results[i].radius* 1),
                     results[i].placements[mod((index+1),results[i].placements.length)],
                      matrix[item][source[mod((index+1),results[i].placements.length)]],
                      (results[i].radius* 1)
                     , results[i].placements[mod((index-1),results[i].placements.length)],
                      matrix[item][source[mod((index-1),results[i].placements.length)]],
                      (results[i].radius* 1),results[i].placements[index])
                    //forbidden på index +-1 max och min värden
                }
                if (i > 0){
                for(var j = 0;j<i; j++){
                    if (results[j]){ 
                        results[j].placements.forEach( (innerItem,innerIndex) =>{ 
                            var non = (matrix[item][results[j].shortestCycle[innerIndex]] -(results[i].radius - results[j].radius))/(results[j].radius* 1);
                            if( non > 0)forbidden.push([mod((innerItem-non),(Math.PI*2)),mod((innerItem+non),(Math.PI*2))]);
                            //if( non > 0)console.log([mod((innerItem-non),(Math.PI*2)),mod((innerItem+non),(Math.PI*2))],"weooo",Array.from(forbidden));
                            //if(!( non > 0)) console.log('non',non,i,j);
                            //forbidden områden från ringar längre in.
                        })
                    }
                }
            }
            fcopy = Array.from(forbidden);
            var forbiddenDone = [];
            if (forbidden.length>0) {forbiddenDone = forbiddenCalculator(forbidden);
            console.log("bof!",forbidden,fcopy,forbiddenDone,"iiii",i,nn,results[i].placements[index],
            mod(results[i].placements[mod((index-1),results[i].placements.length)]- matrix[item][source[mod((index-1),results[i].placements.length)]]/results[i].radius,Math.PI*2));
            // här ska skrivas test på forbidden, så den bara består av forbidden delarna, vars edges är de platser vi kollar
            var points = Object.assign({}, results[i]); 
            points.id = [item];
            points.rot = [];
            points.pos = forbiddenDone.reduce((sum,add)=> [...sum,...add],[points.placements[index]]).map(item => [item]);
            data = distortionCalculator(i,points,results,matrix,extra,true);
           // console.log(data,'data');
            if (totalDiff[i]> data.bestDif){
                console.log(points.pos[data.bestPlacement][0],i,"wat",item,index,totalDiff[i],data.bestDif);
                results[i].placements[index] = points.pos[data.bestPlacement][0];
                totalDiff[i] = data.bestDif;
            }
            }
            })
        }
    }
    var newDiff = totalDiff.reduce((sum,add)=> add==Infinity?sum:sum+add,0);
    if ( newDiff>= sumDiff) improving = false;
    console.log(totalDiff,nn,newDiff,sumDiff, newDiff >= sumDiff);
    sumDiff = newDiff;
    nn++;
}

// var circle = g.selectAll("g")
//             .data(results)
//             .join("circle")
//             .attr("r", 10)
//             //.attr("id",(d)=> item.shortestCycle[innerIndex]+" : "+innerItem+" , "+Math.sin(innerItem)*item.radius*200+" "+Math.cos(innerItem)*(index)*30)
//             .attr("stroke-opacity", 1)
//             .attr("transform", (d) => "translate("+ (width/2+Math.cos()*(index)*30)+","+(height/2 +Math.sin(innerItem)*(index)*30)+")")
//             //.attr("cy",  height/2 +Math.sin(innerItem)*(index)*30)
//             //.attr("cx",  width/2+ Math.cos(innerItem)*item.radius*200   )
//             //.attr("cx", width/2 +Math.cos(innerItem)*(index)*30)//*item.radius*200   )

//             .style("fill", item.shortestCycle[innerIndex]=="6"?"red":"black")
//         circle.append("text")
//         .text(item.shortestCycle[innerIndex])
//         .attr({
//       "text-anchor": "middle",
//       "font-size": "14",
//       "dy": "10"
//     });

results.forEach((item,index) => {
    item.placements.forEach((innerItem,innerIndex)=> {
    //     var circle = g.append("circle")
    //         .attr("r", 10)
    //         .attr("id", item.shortestCycle[innerIndex]+" : "+innerItem+" , "+Math.sin(innerItem)*item.radius*200+" "+Math.cos(innerItem)*(index)*30)
    //         .attr("stroke-opacity", 1)
    //         .attr("transform","translate("+ (width/2+Math.cos(innerItem)*(index)*30)+","+(height/2 +Math.sin(innerItem)*(index)*30)+")")
    //         //.attr("cy",  height/2 +Math.sin(innerItem)*(index)*30)
    //         //.attr("cx",  width/2+ Math.cos(innerItem)*item.radius*200   )
    //         //.attr("cx", width/2 +Math.cos(innerItem)*(index)*30)//*item.radius*200   )

    //         .style("fill", item.shortestCycle[innerIndex]=="6"?"red":"black")
    //     circle.append("text")
    //     .text(item.shortestCycle[innerIndex])
    //     .attr({
    //   "text-anchor": "middle",
    //   "font-size": "14",
    //   "dy": "10"
    // });
    })
})
console.log(results);
var bla =radialDist( results,k,matrix.length);
var bla2 =focusDist( results,k,matrix.length,matrix);
console.log(bla2,"bal2",bla,matrix,bla.map((item,index)=> item.map((innerItem,innerIndex)=> innerItem/matrix[index][innerIndex])));
console.timeEnd('test');



var res3d = g.selectAll('g')
            .data(results)
            .join("g")
            
            res3d.append("g").append("circle")
            .attr("r", (d,i)=> (i)*400/k)//results[iii].radius*200)
            .attr("stroke-opacity", 1)
            .attr("cy", height/2)
            .attr("cx",  width/2);
var knappar = g.append("g")
            .selectAll('g')
            .data(results.map((item,i)=> {item.ii = i; return item}).filter(d => d))
            .join("g")
            .selectAll("circle")
            .data((d,i) => {
                return   d.placements.map( item => [item,d.ii])
            })
            .join("circle")
            .attr("r",10)
            .attr("id", (de,i)=> results[de[1]].shortestCycle[i] )
            .on("mouseover", (d,i)=>{
               var list = [];
               var other = [(width/2+Math.cos(d[0])*(d[1])*400/k),(height/2 + Math.sin(d[0])*(d[1])*400/k)];
                results.forEach((item,index) => {
                    item.placements.forEach( (innerItem,innerIndex) =>{ 
                        //list.push(other);
                        list.push([[[ (width/2+Math.cos(innerItem)*(index)*400/k),+(height/2 +Math.sin(innerItem)*(index)*400/k)],other],matrix[results[d[1]].shortestCycle[i]][results[index].shortestCycle[innerIndex]]])
                    })
                })
                p = d3.line().context(null);

                g.selectAll('path')
                .data(list)
                .join("path")
                .attr("d",d => p(d[0]))
                .attr("stroke", "black")
                .attr("stroke-width", d=> d[1]+"px")

            })
            .on("mouseout", ()=>  g.selectAll('path').remove())
            .attr("stroke-opacity", 1)
            .attr("transform", (da,i) =>{
                //console.log(da,"egfdsg")
                return"translate("+ (width/2+Math.cos(da[0])*(da[1])*400/k)+","+(height/2 +Math.sin(da[0])*(da[1])*400/k)+")"
        })
            //.attr("cy",  height/2 +Math.sin(innerItem)*(index)*30)
            //.attr("cx",  width/2+ Math.cos(innerItem)*item.radius*200   )
            //.attr("cx", width/2 +Math.cos(innerItem)*(index)*30)//*item.radius*200   )

            .style("fill", (de,i)=> results[de[1]].shortestCycle[i]=="6"?"red":"black")
// .attr("cy", item.shortestCycle[innerIndex]=="a6"? height/2 +Math.sin(2.3)*item.radius*200: height/2 +Math.sin(innerItem)*(index)*30)
//             //.attr("cx",  width/2+ Math.cos(innerItem)*item.radius*200   )
//             .attr("cx",  item.shortestCycle[innerIndex]=="a6"? width/2 +Math.cos(2.3)*item.radius*200: width/2 +Math.cos(innerItem)*(index)*30)//*item.radius*200   )

function tsp (distances,center,indis,solver,matrix){
    var constraints = {};
    var variables = {};
    var ints = {};
    var radi = 1*(center.reduce((sum, add)=> sum + add)/center.length);
    if (distances.length<2){
        console.log('korting')
    results= {};
    results["orginal"] = indis;
    results["shortestCycle"] = [""+indis[0]];
    results["placements"] = [2*Math.PI];
    results["center"] = center;
    results["radius"] = radi
    results["distances"] = distances;
    return results;
    }
    
    distances.forEach( (row,index) => {
        row.forEach((a,i)=>{
            if (!(i <= index )){
                variables[indis[index]+","+indis[i]]= {"distance":a, ["u"+indis[i]]: 1, ["d"+indis[i]]: 1,["u"+indis[index]]: 1, ["d"+indis[index]]: 1, "uses":1,"uses2":1,["i"+indis[index]+","+indis[i]]:1}
                constraints["i"+indis[index]+","+indis[i]] = {'max':1};
                ints[indis[index]+","+indis[i]]=1;
            }
        })
    }) ;

    for (b = 0; b < distances.length; b++) {
        constraints["u"+indis[b]] = {"max": 2};
        constraints["d"+indis[b]] = {"min": 2};
    }
    var solver = solver,
    results,
    model = {
        "optimize": "distance",
        "opType": "min",
        "constraints": constraints,
        "variables": variables,
        "ints":ints
    };
    sub = 0;
    notFull = true;
    //console.log(model,'model')
    while (notFull && sub < 100){
        console.log(Object.assign(model,{}),'model');
        results = solver.Solve(model);
        console.log('resss',results,sub);
        // get list of list of vertices in the edges used, if one is used twice get it twice.
        var edges = Object.keys(variables).filter( item => item in results).concat(Object.keys(variables).filter( item => results[item]==2)).map( item => item.split(","));
        var orgEdges = Object.keys(variables).filter( item => item in results);
        var cycle = edges.map(item => []);
        var shortestCycle = [];
        for (i =0; i< edges.length; i++){
            var lengths = 0;
            var goal = edges[i][0];
            var iter = edges[i][1];
            var iterIndex = i;
            cycle[i][0] = goal;
            cycle[i][1] = iter;
            notDone = true;
            cyclePos = 1;
            while (notDone && lengths < 1000 ){
                cyclePos++;
                lengths++;
                theOne = edges.find( (element,index) => element.includes(iter) && index!=iterIndex);
                index = theOne.findIndex(ele => ele == iter);
                invertedIndex = +!index;
                if (goal == theOne[invertedIndex]){
                    notDone = false;
                }else{
                    iterIndex = edges.findIndex( (element,index) => element.includes(iter) && index!=iterIndex);
                    iter = theOne[invertedIndex];
                    cycle[i][cyclePos] = iter;
                }

            }
            if ((cycle[i].length != 0 && cycle[i].length < shortestCycle.length) || shortestCycle.length == 0) shortestCycle = cycle[i]; 
        }
        //console.log(cycle,'fak');
        minLength = Math.min(...cycle.map(item => item.length));
        //console.log((minLength >= distances.length),minLength , distances.length,lengths,'börja inte nu');
        if (minLength >= distances.length){
            notFull = false;
        }else{
            //console.log(cycle.map( item=> item.length),cycle.find( item => item.length == minLength))
             shortestCycleMulti = cycle.filter(item => item.length == minLength).filter((item,index,source)=> {
                for (i=0;i<index;i++){
                    //console.log(item[0],item,source[i],index,source[i].includes(item[0]));
                    if ( source[i].includes(item[0])) return false;
                }
                return true;
            })
            .map( item =>
                Object.keys(model.variables).filter( innerItem => 
                  2 == item.reduce((sum,num)  => (innerItem.split(",")[0] == num || innerItem.split(",")[1] == num)?sum+1:sum,0)
                )
            );
            console.log(shortestCycleMulti,'fakkeee',i);
            shortestCycleMulti.forEach((item,index) => item.forEach(superitem =>{ 
            model.variables[superitem]["v"+sub+","+index]=1;
            model.constraints["v"+sub+","+index] = {"max":minLength-1};
            }));

            }
        sub++;
    }
    console.log(sub);
    results["shortestCycle"] = shortestCycle;
    results["shortest"] = indis.reduce((sum,add,index,source)=>{
        return (sum += matrix[add][source[mod(add-1,indis.length)]])
    })
    results["myShortest"] = shortestCycle.reduce((sum,add,index,source)=>{
        return (sum += matrix[add][source[mod(add-1,indis.length)]])
    },0)
    results["orginal"] = indis;
    placements = shortestCycle.map((matrixIndex,index,source) => index==0?matrix[matrixIndex][source[shortestCycle.length-1]]:matrix[matrixIndex][source[index-1]]);
    console.log(placements,'badabim',placements.reduce((sum,add)=> sum+add),radi);
    results["placements"] = placements.map(item => item*(2*Math.PI)/placements.reduce((sum,add) => sum + add));
    console.log(placements,results["placements"],"answers")
    results["center"] = center;
    results["distances"] = distances;
    for (ii = 1 ; ii < shortestCycle.length; ii++ ) {
        results.placements[ii] += results.placements[ii-1];
    }
    results["radius"] = placements.reduce((sum,add)=> sum+add)/(radi*2*Math.PI)
    results["zoom"] =  placements.reduce((sum,add)=> sum+add)/(radi*2*Math.PI) ;
    return results;
}


function radialDist( results,k,nr){
    var matrix1 = [];
    for (var p = 0; p<nr; p++) matrix1[p] = [];
    for (var i = 0; i<k; i++){
        for(var j = 0;j<=i; j++){
            if (results[i] && results[j]){ 
                results[i].shortestCycle.forEach((item,index) =>{ 
                    results[j].shortestCycle.forEach((innerItem,innerIndex) =>{ 
                        matrix1[innerItem][item] = (results[i].radius -results[j].radius) + results[j].radius * 1 *
                        (Math.abs(results[j].placements[innerIndex]- results[i].placements[index]) )
                        matrix1[item][innerItem] = (results[i].radius -results[j].radius) + results[j].radius * 1 *
                        (Math.abs(results[j].placements[innerIndex]- results[i].placements[index]) )
                        // D (e1, e2) (r2 - r1) + r1 |angle 1 - angle 2|.
                    })
                })

            }
        }
        }
    
    return matrix1;
}
function focusDist( results,k,nr,matrix){
    var matrix1 = [];
    //for (var p = 0; p<nr; p++) matrix1[p] = [];
    for (var i = 0; i<k; i++){
            if (results[i] ){ 
                results[i].shortestCycle.forEach((item,index) =>{ 
                        matrix1[item] = (results[i].radius -matrix[0][item]); 
                })

            }
        }
    
    return matrix1;
}



console.log(forbiddenCalculator([
    [1,2],
    [1.5,3],
    [4,5],
    [5.5,1.5],
    [6,2]
]));
function forbiddenCalculator (source){
    copy = Array.from(source);
    newlist = [];
    notDone = true;
    source.sort((a,b) => a[0] - b[0]);
    sortedcopy = Array.from(source);
    front = source.shift();
    if (front[0]> front[1]) front[1] +=(Math.PI*2);
    while (source.length>0){
        potent = source.shift();
        //console.log(front,potent,newlist);
        if (potent[0]> potent[1]) potent[1] +=(Math.PI*2);
        //console.log(front[1],potent[0] ,potent[0]> front[1] ,newlist,"ute");
        if (potent[0]> front[1]){
            newlist.push([front[0],front[1]%(Math.PI*2)]);
            front = potent;
        }else{
            front = [Math.min(front[0],potent[0]),Math.max(front[1],potent[1])]
        }
    }
    //console.log(newlist,"nya saker",front,copy,sortedcopy);
    if (front[1]>=(Math.PI*2)){
        front[1] = front[1]%(Math.PI*2);
        while (notDone && newlist.length >0){
            //console.log(newlist,copy,front);
            if(front[1]>=newlist[0][0]){ 
                front[1] = Math.max(newlist.shift()[1],front[1]);
            }else{
                notDone = false;
            }
        }
    }
    newlist.push(front);
        return newlist;

}




function mod(n, m) {
  return ((n % m) + m) % m;
}


function bucketing(data,k){
    var output = [];
    //data[0] = (data[1]+data[0]);
    var fixed = data.map((item,index,source) => {
    if (index!=0){
        return [item-source[index-1],item,source[index-1], (item+source[index-1])/2,index]
    }
}).slice(1);
    while (output.length< k){
    console.log([...fixed],"fuck");
    var first = fixed.sort((a,b)=> b[0] -a[0]).shift(0);
    if (first[4]===1){
        fixed.push([first[0]/2,first[1]/2,0,1]);
    }else{
    fixed.push([first[0]/2,first[1],first[3],(first[1]+first[3])/2,false]);
    fixed.push([first[0]/2,first[3],first[2],(first[3]+first[2])/2,false]);
    }
    output.push(first);
    }
    return output;


}

function distortionCalculator(i,points,results,matrix,extra = [],countI = false){
    var bestDif = Infinity;
    var bestPos = 0;
    var difference;
    var bestPlacement =0;
    console.log('pointsss',points,i)
    for (var posIndex = 0; posIndex< points.pos.length; posIndex++){
        difference = 0;
        if( i > 0){
        for(var j = 0;j<i; j++){
            if (points && results[j]){ 
                difference +=  points.id.reduce((sum,item,index) =>{ 
                return (sum + results[j].shortestCycle.reduce((innerSum,innerItem,innerIndex) =>{ 
                var distor = (((points.radius -results[j].radius) + results[j].radius *  1*
                (Math.abs(results[j].placements[innerIndex]- points.pos[posIndex][index] ))) / matrix[item][innerItem])
                // D (e1, e2) (r2 - r1) + r1 |angle 1 - angle 2|.
                //console.log('distor',distor,i,posIndex,points.pos[posIndex][index],(points.radius -results[j].radius) + results[j].radius * 
               // (Math.abs(results[j].placements[innerIndex]- points.pos[posIndex][index] )) , matrix[item][innerItem]);


                
                return( distor<1?innerSum+100:innerSum+distor)},0))},0)
            }
        }
        }
        if (results[i] && countI){
            difference +=  points.id.reduce((sum,item,index) =>{ 
                return (sum + results[i].shortestCycle.reduce((innerSum,innerItem,innerIndex) =>{ 
                    if (item == innerItem) return 0;
                var distor1 = (( results[i].radius *  1 *
                (Math.abs((results[i].placements[innerIndex]) - points.pos[posIndex][index] ))) / matrix[item][innerItem])
               // if ((item==15 && innerItem==18) ||(item==13 && innerItem==17)) console.log(distor1,'bam bam bam!', ( distor1<1?100:distor1));
                return( distor1<1?innerSum+100:innerSum+distor1)},0))},0)
        }
        // console.log(difference[i],bestDif)
        //extra[i][posIndex] = difference; 
        if (difference < bestDif ){
            bestDif = difference;
            bestPlacement = posIndex;
        }
    }
    //console.log(difference," diff ",i);
    return {"bestDif":bestDif,"bestPlacement":bestPlacement,"extra":extra}
    
}




</script>